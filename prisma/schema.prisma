datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-3.0.x"]
}

// ============================================
// MODULE 1: USERS, ROLES & AUTH
// ============================================

enum UserRole {
  ADMIN
  MANAGER
  CASHIER
  KITCHEN  // Rôle cuisine
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model User {
  id            String       @id @default(cuid())
  email         String       @unique
  name          String
  passwordHash  String
  role          UserRole     @default(CASHIER)
  status        UserStatus   @default(ACTIVE)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  sessions      Session[]
  auditLogs     AuditLog[]
  stockMovements StockMovement[]
  investments   Investment[]
  expenses      Expense[]
  inventorySessions InventorySession[]
  sales         Sale[]
  kitchenOrders KitchenOrder[]  // Commandes préparées
  deliveries    DeliveryInfo[]  // Livraisons effectuées
  
  // HR / Payroll
  phone         String?
  baseSalary    Decimal?     @db.Decimal(10, 2)
  salaryAdvances SalaryAdvance[]
  payrolls       Payroll[]

  @@index([email])
  @@index([role])
  @@map("users")
}

// ============================================
// MODULE 7: HR & PAYROLL
// ============================================

enum AdvanceStatus {
  PENDING   // Demandé / En cours
  APPROVED  // Approuvé
  REJECTED  // Refusé
  PAID      // Versé (Money Out)
  DEDUCTED  // Déduit du salaire (Finalisé)
}

model SalaryAdvance {
  id          String        @id @default(cuid())
  userId      String
  amount      Decimal       @db.Decimal(10, 2)
  date        DateTime      @default(now())
  reason      String?
  status      AdvanceStatus @default(PENDING)
  
  // Link to Expense (when money actually leaves cash register)
  expenseId   String?       @unique 
  
  // Link to Payroll (when deducted)
  payrollId   String?
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  user        User          @relation(fields: [userId], references: [id])
  payroll     Payroll?      @relation(fields: [payrollId], references: [id])
  expense     Expense?      @relation(fields: [expenseId], references: [id]) // Optional link if tracked as expense

  @@index([userId])
  @@index([status])
  @@index([date])
  @@map("salary_advances")
}

model Payroll {
  id              String    @id @default(cuid())
  userId          String
  
  month           Int       // 1-12
  year            Int       // 2024, 2025...
  
  baseAmount      Decimal   @db.Decimal(10, 2) // Salaire de base ce mois-là
  advancesTotal   Decimal   @default(0) @db.Decimal(10, 2) // Total avances déduites
  bonus           Decimal   @default(0) @db.Decimal(10, 2) // Prime éventuelle
  penalty         Decimal   @default(0) @db.Decimal(10, 2) // Sanction éventuelle
  
  netPaid         Decimal   @db.Decimal(10, 2) // = Base + Bonus - Penalty - Advances
  
  paymentDate     DateTime  @default(now())
  status          String    @default("COMPLETED") // COMPLETED, DRAFT
  
  notes           String?
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  user            User      @relation(fields: [userId], references: [id])
  advances        SalaryAdvance[]

  @@unique([userId, month, year]) // Un seul bulletin de paie par employé par mois
  @@map("payrolls")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  token        String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  // Relations
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("sessions")
}

model AuditLog {
  id          String   @id @default(cuid())
  userId      String
  action      String   // e.g., "LOGIN", "CREATE_PRODUCT", "DELETE_SALE", etc.
  entity      String?  // e.g., "Product", "Sale", "User"
  entityId    String?  // ID of the affected entity
  metadata    Json?    // Additional data (before/after, IP, etc.)
  createdAt   DateTime @default(now())

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// MODULE 2: PRODUCTS, SALE SPACES & PRICING
// ============================================

// Type principal du produit
enum ProductType {
  BEVERAGE        // Boisson (unité de base: bouteille)
  FOOD            // Nourriture (unité de base: plat)
  NON_VENDABLE    // Produits non vendables (fournitures, etc.)
}

// Catégories BOISSONS
enum BeverageCategory {
  BIERE           // Bière
  SUCRE           // Boisson sucrée (Coca, Fanta, etc.)
  EAU             // Eau minérale
  VIN             // Vin
  WHISKY          // Whisky et spiritueux
  JUS             // Jus naturel
  ENERGIE         // Boisson énergisante
}

// Catégories NOURRITURE
enum FoodCategory {
  GRILLADE        // Grillade (poulet braisé, brochette)
  FAST_FOOD       // Fast-food (burger, etc.)
  ACCOMPAGNEMENT  // Accompagnement (frites, riz)
  DESSERT         // Dessert
  PLAT_PRINCIPAL  // Plat principal
}

// Tailles de produits (Petit/Gros)
enum ProductSize {
  SMALL           // Petit (ex: Coca petit)
  LARGE           // Gros (ex: Coca gros)
  STANDARD        // Taille standard (pas de variation)
}

// Unité de vente (base stock)
enum SaleUnit {
  BOTTLE          // Bouteille (unité de base boisson)
  PLATE           // Plat (unité de base nourriture)
  HALF_PLATE      // Demi-plat
  MEASURE         // Mesure (pour whisky: 4cl, 5cl, etc.)
  PIECE           // Pièce/Unité
}

// Devise supportée
enum Currency {
  CDF             // Franc Congolais
  USD             // Dollar Américain
}

// Exchange Rate Settings (Taux de change CDF/USD)
model ExchangeRate {
  id          String   @id @default(cuid())
  rateUsdToCdf Decimal @db.Decimal(10, 2) // 1 USD = X CDF
  effectiveDate DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  active      Boolean  @default(true)

  @@index([effectiveDate])
  @@index([active])
  @@map("exchange_rates")
}

// Sale Spaces (VIP, Terrasse, etc.)
model SaleSpace {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  prices      ProductPrice[]

  @@map("sale_spaces")
}

// Products (LOGIQUE MÉTIER OFFICIELLE)
model Product {
  id              String      @id @default(cuid())
  name            String
  type            ProductType // BEVERAGE, FOOD, NON_VENDABLE
  
  // Catégories selon le type
  beverageCategory BeverageCategory? // Si BEVERAGE
  foodCategory     FoodCategory?     // Si FOOD
  
  // Taille (Petit/Gros pour boissons sucrées, whisky, etc.)
  size            ProductSize @default(STANDARD)
  
  // Unité de vente (base stock)
  saleUnit        SaleUnit    // BOTTLE (boisson), PLATE (nourriture), MEASURE (whisky)
  unitValue       Decimal?    @db.Decimal(10, 2) // Valeur mesure (4cl, 5cl pour whisky)

  // Conditionnement d'achat
  purchaseUnit    String?     // Ex: "Carton", "Casier", "Sachet"
  packingQuantity Int?        @default(1) // Ex: 24 (bouteilles/casiers), 1 (sachet)
  
  vendable        Boolean     @default(true)
  active          Boolean     @default(true)
  imageUrl        String?
  description     String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  prices          ProductPrice[]
  costs           ProductCost[]
  stockItems      StockItem[]
  stockMovements  StockMovement[]
  inventoryItems  InventoryItem[]
  saleItems       SaleItem[]

  @@index([type])
  @@index([beverageCategory])
  @@index([foodCategory])
  @@index([size])
  @@index([active])
  @@index([vendable])
  @@index([active, vendable])
  @@map("products")
}

// Product Prices (multi-devise: CDF et USD)
model ProductPrice {
  id          String   @id @default(cuid())
  productId   String
  spaceId     String
  
  // Prix dans les deux devises
  priceUsd    Decimal  @db.Decimal(10, 2)
  priceCdf    Decimal  @db.Decimal(10, 2)
  
  // Pour whisky: prix par unité de vente
  // Ex: Whisky peut avoir prix bouteille ET prix mesure (4cl)
  forUnit     SaleUnit @default(BOTTLE) // BOTTLE ou MEASURE
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  space       SaleSpace @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  @@unique([productId, spaceId, forUnit])
  @@index([productId])
  @@index([spaceId])
  @@map("product_prices")
}

// Product Costs (coûts en USD, conversion auto vers CDF)
model ProductCost {
  id          String   @id @default(cuid())
  productId   String
  
  // Coût unitaire en USD (devise de référence)
  unitCostUsd Decimal  @db.Decimal(10, 2)
  
  // Coût en CDF (calculé avec taux de change)
  unitCostCdf Decimal  @db.Decimal(10, 2)
  
  // Pour quel unité (BOTTLE, PLATE, MEASURE)
  forUnit     SaleUnit @default(BOTTLE)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, forUnit])
  @@map("product_costs")
}

// ============================================
// DYNAMIC CATEGORIES METADATA
// ============================================
// Hybrid approach: Keep enums for validation, add metadata for customization

// Product Type Metadata (for custom labels and management)
model ProductTypeMetadata {
  id          String   @id @default(cuid())
  code        String   @unique  // "BEVERAGE", "FOOD", "NON_VENDABLE"
  label       String              // "Boisson", "Nourriture"
  labelEn     String?             // "Beverage", "Food" (optional)
  description String?
  active      Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([active])
  @@index([sortOrder])
  @@map("product_type_metadata")
}

// Category Metadata (for custom labels and adding new categories)
model CategoryMetadata {
  id          String   @id @default(cuid())
  code        String   @unique  // "BIERE", "WHISKY", "GRILLADE", etc.
  productType String              // "BEVERAGE" ou "FOOD"
  label       String              // "Bière", "Whisky", "Grillade"
  labelEn     String?             // English label (optional)
  description String?
  active      Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([productType])
  @@index([active])
  @@index([sortOrder])
  @@map("category_metadata")
}


// ============================================
// MODULE 3: STOCK, INVESTMENT & TRACKING
// ============================================

enum StockLocation {
  DEPOT     // Stock central / Réserve
  FRIGO     // Vente directe (Boissons, etc.)
  CASIER    // Stock tampon (Boissons)
  ECONOMAT  // Stock SEC (Riz, Pâtes, Huile, etc.)
  CUISINE   // En cours d'utilisation
}

enum StockMovementType {
  IN          // Achat / Entrée
  OUT         // Vente
  TRANSFER    // Déplacement interne
  LOSS        // Perte / Casse / Vol
  ADJUSTMENT  // Correction inventaire
}

enum FundSource {
  OWNER_CAPITAL  // Poche du patron
  CASH_REGISTER  // Caisse du restaurant
}


// Catégories de dépenses dynamiques
model ExpenseCategory {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  expenses    Expense[]

  @@map("expense_categories")
}

// 1. STOCK REEL (Snapshot)
model StockItem {
  id          String        @id @default(cuid())
  productId   String
  location    StockLocation
  quantity    Decimal       @db.Decimal(10, 2) // Supporte 0.5 mesure etc.
  
  updatedAt   DateTime      @updatedAt

  // Relations
  product     Product       @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, location])
  @@map("stock_items")
}

// 2. STOCK MOVEMENTS (History/Traceability)
// "Bank Statement" for products
model StockMovement {
  id            String            @id @default(cuid())
  productId     String
  type          StockMovementType
  
  quantity      Decimal           @db.Decimal(10, 2)
  
  fromLocation  StockLocation?    // Null si Achat externe
  toLocation    StockLocation?    // Null si Perte/Vente
  
  reason        String?           // "Casse serveur", "Achat facture #123"
  
  // Financial tracking of the movement
  costValue     Decimal?          @db.Decimal(10, 2) // Valeur d'achat de ce qui bouge
  
  userId        String?           // Qui a fait l'action
  createdAt     DateTime          @default(now())

  // Relations
  product       Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  user          User?             @relation(fields: [userId], references: [id])
  investment    Investment?       @relation(fields: [investmentId], references: [id])
  investmentId  String?

  @@index([productId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

// 3. INVESTISSEMENTS (Money In -> Stock)
model Investment {
  id              String      @id @default(cuid())
  date            DateTime    @default(now())
  
  // Source des fonds
  source          FundSource  @default(OWNER_CAPITAL)
  
  // Totaux
  totalAmount     Decimal     @db.Decimal(12, 2) // Montant total en USD
  totalAmountCdf  Decimal?    @db.Decimal(15, 2) // Montant total original en CDF (si payé en CDF)
  exchangeRate    Decimal?    @db.Decimal(10, 2) // Taux utilisé pour la conversion
  
  // Split pour ROI (en USD)
  vendableAmount    Decimal   @db.Decimal(12, 2) // Part stock revendable
  nonVendableAmount Decimal   @db.Decimal(12, 2) // Part consommable
  
  // ROI Attendu
  expectedRevenue   Decimal   @db.Decimal(12, 2)
  expectedProfit    Decimal   @db.Decimal(12, 2)
  
  description     String?
  userId          String
  
  createdAt       DateTime    @default(now())
  
  // Relations
  user            User        @relation(fields: [userId], references: [id])
  movements       StockMovement[] 

  @@index([date])
  @@index([source])
  @@map("investments")
}

// 4. DEPENSES GENERALES (Money Out -> Non-Stock)
model Expense {
  id              String          @id @default(cuid())
  date            DateTime        @default(now())
  
  description     String
  amount          Decimal         @db.Decimal(10, 2)
  
  categoryId      String          // Link to dynamic categories
  source          FundSource      @default(CASH_REGISTER)
  
  userId          String
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  user            User            @relation(fields: [userId], references: [id])
  category        ExpenseCategory @relation(fields: [categoryId], references: [id])
  salaryAdvance   SalaryAdvance?

  @@index([date])
  @@index([categoryId])
  @@map("expenses")
}

// 5. INVENTORY SESSIONS (Contrôle Physique)
model InventorySession {
  id            String    @id @default(cuid())
  date          DateTime  @default(now()) // Date de l'inventaire
  status        String    @default("OPEN") // OPEN, CLOSED
  
  totalVariance Decimal?  @db.Decimal(10, 2) // Écart total valorisé en USD
  
  userId        String    // Celui qui a ouvert/fermé
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  user          User      @relation(fields: [userId], references: [id])
  items         InventoryItem[]

  @@map("inventory_sessions")
}

model InventoryItem {
  id                String            @id @default(cuid())
  sessionId         String
  productId         String
  location          StockLocation
  
  expectedQuantity  Decimal           @db.Decimal(10, 2) // Ce que le système disait
  actualQuantity    Decimal           @db.Decimal(10, 2) // Ce qu'on a compté
  
  variance          Decimal           @db.Decimal(10, 2) // actual - expected
  
  // Relations
  session           InventorySession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  product           Product           @relation(fields: [productId], references: [id])

  @@index([sessionId])
  @@map("inventory_items")
}


// ============================================
// MODULE 4: CLIENTS & LOYALTY
// ============================================

model Client {
  id            String   @id @default(cuid())
  name          String
  phone         String?  @unique
  email         String?
  points        Int      @default(0)
  notes         String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  sales         Sale[]
  loyaltyHistory LoyaltyTransaction[]

  @@map("clients")
}

model LoyaltyTransaction {
  id            String   @id @default(cuid())
  clientId      String
  amount        Int      // Positive = earned, Negative = used
  reason        String?  // e.g. "Purchase #1024"
  
  saleId        String?
  
  createdAt     DateTime @default(now())

  // Relations
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  sale          Sale?    @relation(fields: [saleId], references: [id])

  @@index([clientId])
  @@map("loyalty_transactions")
}

// ============================================
// MODULE 5: POS SALES
// ============================================

enum PaymentMethod {
  CASH
  CARD
  MOBILE_MONEY
  AIRTEL_MONEY    // Airtel Money
  ORANGE_MONEY    // Orange Money
  AFRIMONEY       // Afrimoney
  MPESA           // M-Pesa
  LOYALTY_POINTS
  SPLIT           // Mixed payment
  OTHER
}

enum SaleStatus {
  DRAFT           // Brouillon (non payé)
  PENDING_PAYMENT // En attente de paiement
  COMPLETED       // Payée et complétée
  CANCELLED       // Annulée
}

enum OrderType {
  DINE_IN    // Sur place au restaurant
  DELIVERY   // Livraison à domicile
  TAKEAWAY   // À emporter
}

enum OrderStatus {
  PENDING        // En attente
  IN_PREPARATION // En préparation
  READY          // Prête à servir/livrer
  DELIVERED      // Livrée/Servie
}

enum DeliveryStatus {
  PENDING    // En attente
  ASSIGNED   // Livreur assigné
  IN_TRANSIT // En route
  DELIVERED  // Livrée
  FAILED     // Échec livraison
}


model Sale {
  id            String      @id @default(cuid())
  ticketNum     String      @unique // E.g. "TK-10001"
  
  clientId      String?
  userId        String      // Cashier
  
  status        SaleStatus  @default(COMPLETED)
  paymentMethod PaymentMethod @default(CASH)
  orderType     OrderType   @default(DINE_IN)  // Type de commande
  
  // Financials
  totalBrut     Decimal     @db.Decimal(10, 2)
  discount      Decimal     @default(0) @db.Decimal(10, 2)
  totalNet      Decimal     @db.Decimal(10, 2)
  
  // Exact CDF Amount (avoid rounding errors)
  totalCdf      Decimal     @default(0) @db.Decimal(15, 2)
  
  // Réduction (Admin/Manager uniquement)
  discountType  String?     // "PERCENTAGE" ou "FIXED"
  discountValue Decimal?    @db.Decimal(10, 2)
  discountBy    String?     // User ID qui a appliqué la réduction
  
  // Points
  pointsEarned  Int         @default(0)
  pointsUsed    Int         @default(0)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  client        Client?     @relation(fields: [clientId], references: [id])
  user          User        @relation(fields: [userId], references: [id])
  items         SaleItem[]
  loyaltyTx     LoyaltyTransaction[]
  kitchenOrders KitchenOrder[]  // Commandes cuisine
  deliveryInfo  DeliveryInfo?   // Info livraison

  @@index([createdAt])
  @@index([clientId])
  @@index([userId])
  @@index([status])
  @@index([orderType])
  @@map("sales")
}

model SaleItem {
  id            String   @id @default(cuid())
  saleId        String
  productId     String
  
  quantity      Decimal  @db.Decimal(10, 2)
  
  // Snapshot prices at moment of sale
  unitPrice     Decimal  @db.Decimal(10, 2)
  totalPrice    Decimal  @db.Decimal(10, 2)
  
  // Cost tracking
  unitCost      Decimal  @default(0) @db.Decimal(10, 2)
  
  // Relations
  sale          Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)
  product       Product  @relation(fields: [productId], references: [id])

  @@index([saleId])
  @@index([productId])
  @@map("sale_items")
}

// ============================================
// MODULE 6: KITCHEN & DELIVERY
// ============================================

model KitchenOrder {
  id          String      @id @default(cuid())
  saleId      String
  orderType   OrderType   @default(DINE_IN)
  status      OrderStatus @default(PENDING)
  priority    Int         @default(0)  // Priorité (0 = normale, 1+ = urgente)
  preparedBy  String?     // User ID du cuisinier
  preparedAt  DateTime?
  deliveredAt DateTime?
  notes       String?     // Notes spéciales pour la cuisine
  createdAt   DateTime    @default(now())
  
  // Relations
  sale        Sale        @relation(fields: [saleId], references: [id], onDelete: Cascade)
  preparer    User?       @relation(fields: [preparedBy], references: [id])
  
  @@index([status])
  @@index([orderType])
  @@index([createdAt])
  @@index([saleId])
  @@map("kitchen_orders")
}

model DeliveryInfo {
  id              String         @id @default(cuid())
  saleId          String         @unique
  address         String
  phone           String
  instructions    String?        // Instructions spéciales
  estimatedTime   DateTime?      // Heure de livraison estimée
  deliveryStatus  DeliveryStatus @default(PENDING)
  deliveredBy     String?        // User ID du livreur
  deliveredAt     DateTime?
  createdAt       DateTime       @default(now())
  
  // Relations
  sale            Sale           @relation(fields: [saleId], references: [id], onDelete: Cascade)
  deliverer       User?          @relation(fields: [deliveredBy], references: [id])
  
  @@index([deliveryStatus])
  @@index([saleId])
  @@map("delivery_info")
}
